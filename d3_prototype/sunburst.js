// Convert from https://observablehq.com/@kerryrodden/sequences-sunburst


go();

async function go(){
    await drawSunburst('AU.csv', '#chart1');
    await drawSunburst('BR.csv', '#chart2');

    let charts = document.querySelectorAll('.sunburst');
    
    charts.forEach(chart => {
        let path = document.querySelector('#sunburst-output');

        // Update chart visual, absolute, percentage and path output
        chart.addEventListener('mouseover', (e) => {
            if (e.target instanceof SVGPathElement) {
                let dataPath = e.target.getAttribute('data-path');
                path.innerHTML = dataPath.replaceAll('_', ' ').replaceAll('-', ' - ');
                // Highlight same path in all charts, update absolute and percentage
                charts.forEach(chart => {
                    let svg = chart.childNodes[0];

                    let percentage = svg.querySelector(`.percentage`);
                    let absolute = svg.querySelector(`.absolute`);

                    let rValue = svg.getAttribute('data-rValue');

                    let selectedPath = chart.querySelector(`[data-path='${dataPath}']`);
                    if (selectedPath) {
                        selectedPath.setAttribute('fill-opacity', '1.0');

                        let dValue = selectedPath.getAttribute('data-dValue');
                        percentage.innerHTML = `${((100 * dValue) / rValue).toPrecision(3)}%`
                        absolute.innerHTML = `${dValue} of ${rValue}`;

                        // If path is child, highlight parent as well
                        let pathArray = dataPath.split('-');
                        if (pathArray.length === 2) {
                            let selectedParent = chart.querySelector(`[data-path='${pathArray[0]}']`);
                            selectedParent.setAttribute('fill-opacity', '1.0');
                        }
                    } else {
                        percentage.innerHTML = '0%';
                        absolute.innerHTML = `0 of ${rValue}`;
                    }
                });
            }
        });

        // Reset chart absolute, percentage and path output
        chart.addEventListener('mouseout', (e) => {
            let dataPath = e.target.getAttribute('data-path');

            // Reset same path in all charts, reset absolute and percentage
            charts.forEach(chart => {
                let svg = chart.childNodes[0];

                let percentage = svg.querySelector(`.percentage`);
                let absolute = svg.querySelector(`.absolute`);

                let rValue = svg.getAttribute('data-rValue');
                
                percentage.innerHTML = '0%';
                absolute.innerHTML = `0 of ${rValue}`;
                path.innerHTML = 'None';

                let selectedPath = chart.querySelector(`[data-path='${dataPath}']`);
                    if (selectedPath) {
                        selectedPath.setAttribute('fill-opacity', '0.3');

                        // If path is child, reset parent as well
                        let pathArray = dataPath.split('-');
                        if (pathArray.length === 2) {
                            let selectedParent = chart.querySelector(`[data-path='${pathArray[0]}']`);
                            selectedParent.setAttribute('fill-opacity', '0.3');
                        }
                    }
            });
        });
    });
}

async function drawSunburst(src, target) {
    const csv = await d3.text(src);
    const csvParsed = d3.csvParseRows(csv);
    const hierarchyData = buildHierarchy(csvParsed);

    let width = 640;
    let radius = width / 2;
  
    let partition = data =>
    d3.partition().size([2 * Math.PI, radius * radius])(
        d3
            .hierarchy(data)
            .sum(d => d.value)
            .sort((a, b) => b.value - a.value)
    );

    // Set color here, can be set to name specific color
    // Arrays to be dynamically generated by back-end
    let color = d3
        .scaleOrdinal()
        .domain(['Serotype 1', 'Serotype 2', 'Serotype 3', 'Serotype 4', 'GPSC 1', 'GPSC 2', 'GPSC 3', 'GPSC 4', 'GPSC 5'])
        .range(['#ff0000', '#ffac00', '#f8ff00', '#5bff00', '#43d871', '#43b6d8', '#5443d8', '#b043d8', '#793865']);

    let arc = d3
        .arc()
        .startAngle(d => d.x0)
        .endAngle(d => d.x1)
        .padAngle(1 / radius)
        .padRadius(radius)
        .innerRadius(d => Math.sqrt(d.y0))
        .outerRadius(d => Math.sqrt(d.y1) - 1);

    let mousearc = d3
        .arc()
        .startAngle(d => d.x0)
        .endAngle(d => d.x1)
        .innerRadius(d => Math.sqrt(d.y0))
        .outerRadius(radius);
  
    const chart = await (() => {
        const root = partition(hierarchyData);
        const svg = d3.create("svg");
    
        const element = svg.node();

        const label = svg
            .append("text")
            .attr("text-anchor", "middle")
            .attr("fill", "#000")
    
        label
            .append("tspan")
            .attr("class", "percentage")
            .attr("x", 0)
            .attr("y", 0)
            .attr("dy", "-0.1em")
            .attr("font-size", "3em")
            .text("0%");
    
        label
            .append("tspan")
            .attr("class", "absolute")
            .attr("x", 0)
            .attr("y", 0)
            .attr("dy", "1.5em")
            .attr("font-size", "1.5em")
            .text(`0 of ${root.value}`);
        
        // label
        //     .append("tspan")
        //     .attr("class", "path")
        //     .attr("x", 0)
        //     .attr("y", 0)
        //     .attr("dy", "3em")
        //     .attr("font-size", "1.5em")
        //     .text("");
    
        svg
            .attr("viewBox", `${-radius} ${-radius} ${width} ${width}`)
            .style("max-width", `${width}px`)
            .style("font", "12px sans-serif")
            .attr('data-rValue', `${root.value}`);;
    
        const path = svg
            .append("g")
            .selectAll("path")
            .data(
            root.descendants().filter(d => {
                // Don't draw the root node, and for efficiency, filter out nodes that would be too small to see
                return d.depth && d.x1 - d.x0 > 0.001;
            })
            )
            .join("path")
            .attr("fill", d => color(d.data.name))
            .attr("fill-opacity", 0.3)
            .attr("d", arc)
            .attr('data-path', d => {
                const sequence = d
                    .ancestors()
                    .reverse()
                    .slice(1);

                const output = [];
                    sequence.forEach(node => {
                        output.push(node.data.name)
                    });
                return `${output.join('-').replaceAll(' ','_')}`;
            })
            .attr('data-dValue', d => `${d.value}`);
    
        // Setting mouseleave and mouseenter events
        // svg
        //     .append("g")
        //     .attr("fill", "none")
        //     .attr("pointer-events", "all")
        //     .on("mouseleave", () => {
        //         path.attr("fill-opacity", 0.3);
        //         label
        //         .select(".percentage")
        //         .text("0%");
        //         label
        //             .select(".absolute")
        //             .text(`0 of ${root.value}`);
        //         label
        //             .select(".path")
        //             .text("");
        //     })
        //     .selectAll("path")
        //     .data(
        //     root.descendants().filter(d => {
        //         // Don't draw the root node, and for efficiency, filter out nodes that would be too small to see
        //         return d.depth && d.x1 - d.x0 > 0.001;
        //     })
        //     )
        //     .join("path")
        //     .attr("d", mousearc)
        //     .on("mouseenter", (event, d) => {
        //         // Get the ancestors of the current segment, minus the root
        //         const sequence = d
        //             .ancestors()
        //             .reverse()
        //             .slice(1);
        //         // Highlight the ancestors
        //         path.attr("fill-opacity", node =>
        //             sequence.indexOf(node) >= 0 ? 1.0 : 0.3
        //         );
        //         const percentage = ((100 * d.value) / root.value).toPrecision(3);
        //         label
        //             .select(".percentage")
        //             .text(`${percentage}%`);
        //         label
        //             .select(".absolute")
        //             .text(`${d.value} of ${root.value}`);

        //         // Add path
        //         let pathOut = [];
        //         let cur = d;
        //         while (cur.parent) {
        //             pathOut.unshift(cur.data.name);
        //             cur = cur.parent;
        //         }
        //         label
        //             .select(".path")
        //             .text(`${pathOut.join(" - ")}`);
        //     });
        return element;
    })();
    document.querySelector(target).appendChild(chart);
  }
  
  
  function buildHierarchy(csv) {
    // Helper function that transforms the given CSV into a hierarchical format.
    const root = { name: "root", children: [] };
    for (let i = 0; i < csv.length; i++) {
        const sequence = csv[i][0];
        const size = +csv[i][1];
        if (isNaN(size)) {
            // e.g. if this is a header row
            continue;
        }
        const parts = sequence.split("-");
        let currentNode = root;
        for (let j = 0; j < parts.length; j++) {
            const children = currentNode["children"];
            const nodeName = parts[j];
            let childNode = null;
            if (j + 1 < parts.length) {
            // Not yet at the end of the sequence; move down the tree.
            let foundChild = false;
            for (let k = 0; k < children.length; k++) {
                if (children[k]["name"] == nodeName) {
                childNode = children[k];
                foundChild = true;
                break;
                }
            }
            // If we don't already have a child node for this branch, create it.
            if (!foundChild) {
                childNode = { name: nodeName, children: [] };
                children.push(childNode);
            }
            currentNode = childNode;
            } else {
            // Reached the end of the sequence; create a leaf node.
            childNode = { name: nodeName, value: size };
            children.push(childNode);
            }
        }
    }
    return root;
}